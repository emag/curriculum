============
 データ構造
============

Clojure では主要なデータ構造が 4 つあります。

* リスト ``'(1 2 3)``
* ベクター ``[1 2 3]``
* マップ ``{:foo 1 :bar 2}``
* セット ``#{1 2 3}``

それぞれの特徴
==============

リスト
------

リテラル表記は ``'(1 2 3)`` というように丸括弧にシングルクォートを付けてあげる方法です。また ``list`` 関数を使うことでリストを作成出来ます。
データを追加する性能がベクターより良い。 ``conj`` でデータを追加するとリストの先頭に追加する。

ベクター
--------

リテラル表記は ``[1 2 3]`` というようにブラケットを使います。また ``vector`` 関数でベクターを作成出来ます。
インデックス指定でのデータ取得が高速。 ``conj`` でデータを追加するとベクターの最後に追加する。

マップ
------

リテラル表記は ``{:foo 1 :bar 2}`` というようにブレースを使って偶数個の値を囲います(キー/バリューのペアなので)。また ``hash-map`` や ``array-map`` を使うことでマップを作成出来ます。
キー/バリューの組み合わせをひとつのエントリーとしてデータを持つ。 ``conj`` でデータを追加することが出来、 ``seq`` でエントリーのシーケンスを受け取れる。

セット
------

リテラル表記は ``#{1 2 3}`` というようにブレースとシャープを使って表します。また ``hash-set`` を使うことでセットを作成出来ます。
重複したデータを持つことが出来ない。


シーケンスとして扱うことが出来る
================================

次の例に代表するように Clojure のデータ構造はシーケンス(連続したデータ)として扱うことが出来ます。

.. sourcecode:: clojure

  user> (for [n '(1 2 3)] (println n))
  1
  2
  3
  (nil nil nil)
  user> (for [n [1 2 3]] (println n))
  1
  2
  3
  (nil nil nil)
  user> (for [e {:foo 1 :bar 2}] (println e))
  [:foo 1]
  [:bar 2]
  (nil nil)
  user> (for [n #{1 2 3}] (println n))
  1
  3
  2
  (nil nil nil)

(本来 ``for`` と ``println`` のような副作用をもつ操作は組み合わせるべきではないのですが、例を簡単化するために使っています)
